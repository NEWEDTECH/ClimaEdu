Claro! 🤝  
Eu entendi sua preocupação: você quer **um único arquivo** `systemPatterns.md`, completo, organizado, **sem ter que ficar "encaixando pedaços"**.

Então aqui vai a versão **final**, **corrigida** e **com todos os exemplos** já inseridos:  
(Pronto para você **copiar e colar** direto no seu projeto.)

---

# 📄 `memory-bank/systemPatterns.md`

```markdown
# System Patterns

## General Architecture

The system follows **Clean Architecture** with strong adherence to **SOLID** principles and **Object Calisthenics** practices.

The entire application is organized in a **modular** way, where each **functional domain** (user, content, enrollment, assessment, forum, certificate, report) is isolated in its own module.

Each module is divided into:

- `core/entities`: Pure domain entities.
- `core/use-cases`: Use cases representing business actions.
- `infrastructure/repositories`: Data persistence interfaces.
- `infrastructure/implementations`: Specific implementations using the Firebase SDK.
- `index.ts`: Module entry point.

The modular structure facilitates decoupling, scalability, and testability of the system.

---

## Directory Structure Example

```plaintext
src/
  modules/
    user/
      core/
        entities/
          user.entity.ts
        use-cases/
          create-user/
            create-user.use-case.ts
            create-user.input.ts
            create-user.output.ts
      infrastructure/
        repositories/
          user.repository.ts
          implementations/
            user.repository.firebase.ts
      index.ts
  shared/
    firebase/
      firebase-config.ts
      firebase-client.ts
    container/
      containerRegister.ts
  components/
    ui/
      (components generated by shadcn/ui)
  app/
    (Next.js routes and pages)
package.json
tsconfig.json
```

---

## Design Patterns Used

### Clean Architecture
- Use cases and entities are infrastructure-agnostic (they don't know about Firebase, HTTP, or Database).
- Communication happens via interfaces and dependency injection.

### Dependency Injection / Container Pattern
- Using [InversifyJS](https://inversify.io/) to manage dependency injection.
- All UseCases and Repositories are registered in the container using `Symbol.for`.
- React components resolve UseCases directly via the container.

### Object Calisthenics
- Single responsibility per class and method.
- Only one level of indentation per method.
- Preference for early returns (avoiding deep "else" statements).
- Objects must be created in a valid state in the constructor.

### Repository Pattern
- Repositories expose only interfaces in the domain (`core/`).
- Concrete implementations are in `infrastructure/implementations/`, using Firebase.

### Service Layer (Use Cases)
- UseCases are classes that expose a public `execute()` method.
- Every use case receives strongly typed input and returns strongly typed output.

---

## Container Pattern Usage Example

Container registration:

```typescript
// src/shared/container/containerRegister.ts
import { Container } from "inversify";
import { CreateUserUseCase } from "@/modules/user/core/use-cases/create-user/create-user.use-case";
import { UserRepositoryFirebase } from "@/modules/user/infrastructure/repositories/implementations/user.repository.firebase";

export const Register = {
  repository: {
    UserRepository: Symbol.for("UserRepository"),
  },
  user: {
    useCase: {
      CreateUserUseCase: Symbol.for("CreateUserUseCase"),
    },
  },
};

export const container = new Container();

container.bind(Register.repository.UserRepository).toDynamicValue(() => {
  return new UserRepositoryFirebase();
});

container.bind(Register.user.useCase.CreateUserUseCase).toDynamicValue((context) => {
  return new CreateUserUseCase(
    context.container.get(Register.repository.UserRepository)
  );
});
```

Consumption in React:

```typescript
const createUserUseCase = container.get<CreateUserUseCase>(Register.user.useCase.CreateUserUseCase);
await createUserUseCase.execute({ name: "John", email: "john@email.com" });
```

---

## Entity Example

```typescript
// src/modules/user/core/entities/user.entity.ts
export class User {
  constructor(
    public readonly id: string,
    public readonly name: string,
    public readonly email: string,
  ) {
    if (!email.includes('@')) {
      throw new Error('Invalid email');
    }
    if (name.trim().length < 2) {
      throw new Error('Name too short');
    }
  }
}
```

---

## Use Case Example

```typescript
// src/modules/user/core/use-cases/create-user/create-user.use-case.ts
import { UserRepository } from "../../repositories/user.repository";
import { User } from "../../entities/user.entity";
import { CreateUserInput } from "./create-user.input";
import { CreateUserOutput } from "./create-user.output";

export class CreateUserUseCase {
  constructor(private readonly userRepository: UserRepository) {}

  async execute(input: CreateUserInput): Promise<CreateUserOutput> {
    const user = new User(input.id, input.name, input.email);
    await this.userRepository.save(user);
    return { id: user.id };
  }
}
```

---

## Repository Example

Interface:

```typescript
// src/modules/user/infrastructure/repositories/user.repository.ts
import { User } from "../../core/entities/user.entity";

export interface UserRepository {
  save(user: User): Promise<void>;
}
```

Firebase Implementation:

```typescript
// src/modules/user/infrastructure/repositories/implementations/user.repository.firebase.ts
import { UserRepository } from "../user.repository";
import { db } from "@/shared/firebase/firebase-client";
import { collection, addDoc } from "firebase/firestore";
import { User } from "../../../core/entities/user.entity";

export class UserRepositoryFirebase implements UserRepository {
  async save(user: User): Promise<void> {
    const userCollection = collection(db, "users");
    await addDoc(userCollection, {
      id: user.id,
      name: user.name,
      email: user.email,
    });
  }
}
```

---

## External Integrations

- **Firebase Authentication**: User authentication.
- **Firebase Firestore**: Storage of educational data (users, contents, enrollments, etc.).
- **Firebase Storage**: File uploads (videos, PDFs, podcasts).
- **Firebase Messaging**: Push notifications for future events.

---

## General Conventions

- **TypeScript** strict mode (`strict: true`).
- **Clean Architecture and SOLID** patterns are mandatory.
- **Object Calisthenics** applied throughout the code.
- **Memory Bank and `.clinerules`** guide development with the Cline assistant.
