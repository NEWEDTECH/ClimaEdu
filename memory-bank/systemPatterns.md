# System Patterns

## Project Structure

The project follows a modular architecture based on Clean Architecture principles. Each domain is structured independently under `src/_core/modules/`, containing:

- core/entities
- core/use-cases
- infrastructure/repositories
- infrastructure/implementations
- index.ts (module entry point)

The shared code is located in `src/_core/shared/`.

## Dependency Injection

React components on the frontend do not interact directly with the UseCases. Instead, they resolve UseCases via a Dependency Injection Container (Inversify) using Symbols. This pattern ensures low coupling and high testability.

### Modular Container Structure

The Dependency Injection container is organized in a modular structure that mirrors the application's module structure:

- **Container Directory Structure**:
  ```
  src/_core/shared/container/
  ├── container.ts                 # Main container instance
  ├── symbols.ts                   # Main symbols file (imports and re-exports module symbols)
  ├── containerRegister.ts         # Main registration file (uses module-specific registrations)
  ├── index.ts                     # Exports everything from the container directory
  └── modules/                     # Module-specific container files
      ├── institution/             # Institution module container files
      │   ├── symbols.ts           # Institution-specific symbols
      │   └── register.ts          # Institution-specific registrations
      ├── user/                    # User module container files
      │   ├── symbols.ts           # User-specific symbols
      │   └── register.ts          # User-specific registrations
      ├── content/                 # Content module container files
      │   ├── symbols.ts           # Content-specific symbols
      │   └── register.ts          # Content-specific registrations
      └── auth/                    # Auth module container files
          ├── symbols.ts           # Auth-specific symbols
          └── register.ts          # Auth-specific registrations
  ```

- **Import Pattern**:
  Instead of importing directly from individual container files, components and use cases should import from the container index:
  ```typescript
  // Old pattern
  import { container } from '@/_core/shared/container/container';
  import { Register } from '@/_core/shared/container/symbols';
  
  // New pattern
  import { container, Register } from '@/_core/shared/container';
  ```

This modular structure provides several advantages:
1. **Maintainability**: Each module's container code is isolated, making it easier to understand and maintain
2. **Scalability**: New modules can be added without modifying existing files
3. **Organization**: The container structure mirrors the module structure, making it intuitive to navigate
4. **Encapsulation**: Each module's container code is encapsulated, reducing the risk of conflicts

## Authentication Flow

The application uses Firebase Authentication with email link (passwordless) authentication:

1. User enters their email address
2. A magic link is sent to the user's email
3. User clicks the link to authenticate
4. The application verifies the link and authenticates the user

### Email Link Authentication Process

1. **Request Phase**:
   - User enters email on the login page
   - Application calls `sendSignInLinkToEmail` Firebase method
   - Email is stored in localStorage for later verification
   - In production, Firebase sends an email with the authentication link
   - In development with emulators, the link is displayed on the login page

2. **Authentication Phase**:
   - User clicks the authentication link
   - User is redirected to the authentication confirmation page (/auth/confirm)
   - Application verifies the link using `isSignInWithEmailLink` Firebase method
   - Application retrieves the email from localStorage
   - Application calls `signInWithEmailLink` Firebase method with the email and link
   - Firebase authenticates the user and returns a user object
   - Application updates the authentication state and redirects to the home page

3. **Emulator-Specific Handling**:
   - When using the emulator, the application detects the fake API key
   - Instead of using the standard Firebase authentication, it creates a fake user ID
   - This allows the authentication flow to work even with the emulator's limitations
   - The fake user ID is used just like a real user ID for the rest of the application

## Firebase Emulator Support

The application includes special handling for the Firebase emulator:

1. **EmulatorAuthLinks Component**:
   - Displays authentication links generated by the emulator
   - Allows users to authenticate without needing to receive actual emails
   - Only appears in development mode when the emulator is running

2. **EmulatorStatus Component**:
   - Checks if the Firebase emulator is running
   - Provides clear instructions if the emulator is not running
   - Shows links to the emulator UI and auth emulator

3. **Authentication Handling**:
   - The FirebaseAuthService implements a singleton pattern to ensure only one instance exists
   - Authentication state is persisted in localStorage to maintain it across page reloads
   - Special handling for the emulator's limitations with email link authentication

## Import Paths

All imports from the core modules and shared code should use the following paths:

- Core modules: `@/_core/modules/...`
- Shared code: `@/_core/shared/...`

For example:
```typescript
// Container imports (preferred pattern)
import { container, Register } from '@/_core/shared/container';

// Module imports
import { SignInWithEmailLinkUseCase } from '@/_core/modules/auth/core/use-cases/sign-in-with-email-link/sign-in-with-email-link.use-case';
import type { AuthService } from '@/_core/modules/auth/infrastructure/services/AuthService';
